// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny


package appcfg

// MustBoolSlice returns BoolSlice initialized with given values or panics.
func MustBoolSlice(ss ...string) BoolSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v BoolSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustStringArray returns StringArray initialized with given values or panics.
func MustStringArray(ss ...string) StringArray {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v StringArray
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustStringSlice returns StringSlice initialized with given values or panics.
func MustStringSlice(ss ...string) StringSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v StringSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustNotEmptyStringArray returns NotEmptyStringArray initialized with given values or panics.
func MustNotEmptyStringArray(ss ...string) NotEmptyStringArray {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v NotEmptyStringArray
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustNotEmptyStringSlice returns NotEmptyStringSlice initialized with given values or panics.
func MustNotEmptyStringSlice(ss ...string) NotEmptyStringSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v NotEmptyStringSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustEndpointSlice returns EndpointSlice initialized with given values or panics.
func MustEndpointSlice(ss ...string) EndpointSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v EndpointSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustIntSlice returns IntSlice initialized with given values or panics.
func MustIntSlice(ss ...string) IntSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v IntSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustInt64Slice returns Int64Slice initialized with given values or panics.
func MustInt64Slice(ss ...string) Int64Slice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v Int64Slice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustUintSlice returns UintSlice initialized with given values or panics.
func MustUintSlice(ss ...string) UintSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v UintSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustUint64Slice returns Uint64Slice initialized with given values or panics.
func MustUint64Slice(ss ...string) Uint64Slice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v Uint64Slice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustFloat64Slice returns Float64Slice initialized with given values or panics.
func MustFloat64Slice(ss ...string) Float64Slice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v Float64Slice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustPortSlice returns PortSlice initialized with given values or panics.
func MustPortSlice(ss ...string) PortSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v PortSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustListenPortSlice returns ListenPortSlice initialized with given values or panics.
func MustListenPortSlice(ss ...string) ListenPortSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v ListenPortSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustIPNetSlice returns IPNetSlice initialized with given values or panics.
func MustIPNetSlice(ss ...string) IPNetSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v IPNetSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}


// MustHostPortSlice returns HostPortSlice initialized with given values or panics.
func MustHostPortSlice(ss ...string) HostPortSlice {
	if len(ss) == 0 {
		panic("require at least 1 arg")
	}
	var v HostPortSlice
	for _, s := range ss {
		err := v.Set(s)
		if err != nil {
			panic(err)
		}
	}
	v.completed = true
	return v
}
